{"version":3,"file":"wisp-server.mjs","mappings":"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","sources":["webpack://@mercuryworkshop/wisp-js/./node_modules/ipaddr.js/lib/ipaddr.js","webpack://@mercuryworkshop/wisp-js/webpack/bootstrap","webpack://@mercuryworkshop/wisp-js/webpack/runtime/define property getters","webpack://@mercuryworkshop/wisp-js/webpack/runtime/hasOwnProperty shorthand","webpack://@mercuryworkshop/wisp-js/webpack/runtime/make namespace object","webpack://@mercuryworkshop/wisp-js/./src/logging.mjs","webpack://@mercuryworkshop/wisp-js/./src/packet.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/options.mjs","webpack://@mercuryworkshop/wisp-js/./src/compat_browser.mjs","webpack://@mercuryworkshop/wisp-js/./src/websocket.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/net.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/filter.mjs","webpack://@mercuryworkshop/wisp-js/./src/extensions.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/connection.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/wsproxy.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/http.mjs"],"sourcesContent":["(function (root) {\n    'use strict';\n    // A list of regular expressions that match arbitrary IPv4 addresses,\n    // for which a number of weird notations exist.\n    // Note that an address like 0010.0xa5.1.1 is considered legal.\n    const ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n    const ipv4Regexes = {\n        fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        longValue: new RegExp(`^${ipv4Part}$`, 'i')\n    };\n\n    // Regular Expression for checking Octal numbers\n    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');\n    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');\n\n    const zoneIndex = '%[0-9a-z]{1,}';\n\n    // IPv6-matching regular expressions.\n    // For IPv6, the task is simpler: it is enough to match the colon-delimited\n    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n    // the end.\n    const ipv6Part = '(?:[0-9a-f]+::?)+';\n    const ipv6Regexes = {\n        zoneIndex: new RegExp(zoneIndex, 'i'),\n        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),\n        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),\n        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, 'i')\n    };\n\n    // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n    function expandIPv6 (string, parts) {\n        // More than one '::' means invalid adddress\n        if (string.indexOf('::') !== string.lastIndexOf('::')) {\n            return null;\n        }\n\n        let colonCount = 0;\n        let lastColon = -1;\n        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n        let replacement, replacementCount;\n\n        // Remove zone index and save it for later\n        if (zoneId) {\n            zoneId = zoneId.substring(1);\n            string = string.replace(/%.+$/, '');\n        }\n\n        // How many parts do we already have?\n        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n            colonCount++;\n        }\n\n        // 0::0 is two parts more than ::\n        if (string.substr(0, 2) === '::') {\n            colonCount--;\n        }\n\n        if (string.substr(-2, 2) === '::') {\n            colonCount--;\n        }\n\n        // The following loop would hang if colonCount > parts\n        if (colonCount > parts) {\n            return null;\n        }\n\n        // replacement = ':' + '0:' * (parts - colonCount)\n        replacementCount = parts - colonCount;\n        replacement = ':';\n        while (replacementCount--) {\n            replacement += '0:';\n        }\n\n        // Insert the missing zeroes\n        string = string.replace('::', replacement);\n\n        // Trim any garbage which may be hanging around if :: was at the edge in\n        // the source strin\n        if (string[0] === ':') {\n            string = string.slice(1);\n        }\n\n        if (string[string.length - 1] === ':') {\n            string = string.slice(0, -1);\n        }\n\n        parts = (function () {\n            const ref = string.split(':');\n            const results = [];\n\n            for (let i = 0; i < ref.length; i++) {\n                results.push(parseInt(ref[i], 16));\n            }\n\n            return results;\n        })();\n\n        return {\n            parts: parts,\n            zoneId: zoneId\n        };\n    }\n\n    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n    function matchCIDR (first, second, partSize, cidrBits) {\n        if (first.length !== second.length) {\n            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n        }\n\n        let part = 0;\n        let shift;\n\n        while (cidrBits > 0) {\n            shift = partSize - cidrBits;\n            if (shift < 0) {\n                shift = 0;\n            }\n\n            if (first[part] >> shift !== second[part] >> shift) {\n                return false;\n            }\n\n            cidrBits -= partSize;\n            part += 1;\n        }\n\n        return true;\n    }\n\n    function parseIntAuto (string) {\n        // Hexadedimal base 16 (0x#)\n        if (hexRegex.test(string)) {\n            return parseInt(string, 16);\n        }\n        // While octal representation is discouraged by ECMAScript 3\n        // and forbidden by ECMAScript 5, we silently allow it to\n        // work only if the rest of the string has numbers less than 8.\n        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n        if (octalRegex.test(string)) {\n            return parseInt(string, 8);\n        }\n            throw new Error(`ipaddr: cannot parse ${string} as octal`);\n        }\n        // Always include the base 10 radix!\n        return parseInt(string, 10);\n    }\n\n    function padPart (part, length) {\n        while (part.length < length) {\n            part = `0${part}`;\n        }\n\n        return part;\n    }\n\n    const ipaddr = {};\n\n    // An IPv4 address (RFC791).\n    ipaddr.IPv4 = (function () {\n        // Constructs a new IPv4 address from an array of four octets\n        // in network order (MSB first)\n        // Verifies the input.\n        function IPv4 (octets) {\n            if (octets.length !== 4) {\n                throw new Error('ipaddr: ipv4 octet count should be 4');\n            }\n\n            let i, octet;\n\n            for (i = 0; i < octets.length; i++) {\n                octet = octets[i];\n                if (!((0 <= octet && octet <= 255))) {\n                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n                }\n            }\n\n            this.octets = octets;\n        }\n\n        // Special IPv4 address ranges.\n        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n        IPv4.prototype.SpecialRanges = {\n            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n            // RFC3171\n            multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n            // RFC3927\n            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n            // RFC5735\n            loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n            // RFC6598\n            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n            // RFC1918\n            'private': [\n                [new IPv4([10, 0, 0, 0]), 8],\n                [new IPv4([172, 16, 0, 0]), 12],\n                [new IPv4([192, 168, 0, 0]), 16]\n            ],\n            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n            reserved: [\n                [new IPv4([192, 0, 0, 0]), 24],\n                [new IPv4([192, 0, 2, 0]), 24],\n                [new IPv4([192, 88, 99, 0]), 24],\n                [new IPv4([198, 18, 0, 0]), 15],\n                [new IPv4([198, 51, 100, 0]), 24],\n                [new IPv4([203, 0, 113, 0]), 24],\n                [new IPv4([240, 0, 0, 0]), 4]\n            ],\n            // RFC7534, RFC7535\n            as112: [\n                [new IPv4([192, 175, 48, 0]), 24],\n                [new IPv4([192, 31, 196, 0]), 24],\n            ],\n            // RFC7450\n            amt: [\n                [new IPv4([192, 52, 193, 0]), 24],\n            ],\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv4.prototype.kind = function () {\n            return 'ipv4';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv4.prototype.match = function (other, cidrRange) {\n            let ref;\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv4') {\n                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n            }\n\n            return matchCIDR(this.octets, other.octets, 8, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv4 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv4.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 8,\n                128: 7,\n                192: 6,\n                224: 5,\n                240: 4,\n                248: 3,\n                252: 2,\n                254: 1,\n                255: 0\n            };\n            let i, octet, zeros;\n\n            for (i = 3; i >= 0; i -= 1) {\n                octet = this.octets[i];\n                if (octet in zerotable) {\n                    zeros = zerotable[octet];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 8) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 32 - cidr;\n        };\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv4.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv4.prototype.toByteArray = function () {\n            return this.octets.slice(0);\n        };\n\n        // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n        IPv4.prototype.toIPv4MappedAddress = function () {\n            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n        };\n\n        // Symmetrical method strictly for aligning with the IPv6 methods.\n        IPv4.prototype.toNormalizedString = function () {\n            return this.toString();\n        };\n\n        // Returns the address in convenient, decimal-dotted format.\n        IPv4.prototype.toString = function () {\n            return this.octets.join('.');\n        };\n\n        return IPv4;\n    })();\n\n    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 4) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Checks if a given string is formatted like IPv4 address.\n    ipaddr.IPv4.isIPv4 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks if a given string is a valid IPv4 address.\n    ipaddr.IPv4.isValid = function (string) {\n        try {\n            new this(this.parser(string));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a valid IPv4 address in CIDR notation.\n    ipaddr.IPv4.isValidCIDR = function (string) {\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a full four-part IPv4 Address.\n    ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 4) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Tries to parse and validate a string with IPv4 address.\n    // Throws an error if it fails.\n    ipaddr.IPv4.parse = function (string) {\n        const parts = this.parser(string);\n\n        if (parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n        }\n\n        return new this(parts);\n    };\n\n    // Parses the string as an IPv4 Address with CIDR Notation.\n    ipaddr.IPv4.parseCIDR = function (string) {\n        let match;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            const maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 32) {\n                const parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n    };\n\n    // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n    // value representing last three octets; this corresponds to a class C\n    // address) are omitted due to classless nature of modern Internet.\n    ipaddr.IPv4.parser = function (string) {\n        let match, part, value;\n\n        // parseInt recognizes all that octal & hexadecimal weirdness for us\n        if ((match = string.match(ipv4Regexes.fourOctet))) {\n            return (function () {\n                const ref = match.slice(1, 6);\n                const results = [];\n\n                for (let i = 0; i < ref.length; i++) {\n                    part = ref[i];\n                    results.push(parseIntAuto(part));\n                }\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.longValue))) {\n            value = parseIntAuto(match[1]);\n            if (value > 0xffffffff || value < 0) {\n                throw new Error('ipaddr: address outside defined range');\n            }\n\n            return ((function () {\n                const results = [];\n                let shift;\n\n                for (shift = 0; shift <= 24; shift += 8) {\n                    results.push((value >> shift) & 0xff);\n                }\n\n                return results;\n            })()).reverse();\n        } else if ((match = string.match(ipv4Regexes.twoOctet))) {\n            return (function () {\n                const ref = match.slice(1, 4);\n                const results = [];\n\n                value = parseIntAuto(ref[1]);\n                if (value > 0xffffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push((value >> 16) & 0xff);\n                results.push((value >>  8) & 0xff);\n                results.push( value        & 0xff);\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.threeOctet))) {\n            return (function () {\n                const ref = match.slice(1, 5);\n                const results = [];\n\n                value = parseIntAuto(ref[2]);\n                if (value > 0xffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push(parseIntAuto(ref[1]));\n                results.push((value >> 8) & 0xff);\n                results.push( value       & 0xff);\n\n                return results;\n            })();\n        } else {\n            return null;\n        }\n    };\n\n    // A utility function to return subnet mask in IPv4 format given the prefix length\n    ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 32) {\n            throw new Error('ipaddr: invalid IPv4 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 4) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // An IPv6 address (RFC2460)\n    ipaddr.IPv6 = (function () {\n        // Constructs an IPv6 address from an array of eight 16 - bit parts\n        // or sixteen 8 - bit parts in network order(MSB first).\n        // Throws an error if the input is invalid.\n        function IPv6 (parts, zoneId) {\n            let i, part;\n\n            if (parts.length === 16) {\n                this.parts = [];\n                for (i = 0; i <= 14; i += 2) {\n                    this.parts.push((parts[i] << 8) | parts[i + 1]);\n                }\n            } else if (parts.length === 8) {\n                this.parts = parts;\n            } else {\n                throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n            }\n\n            for (i = 0; i < this.parts.length; i++) {\n                part = this.parts[i];\n                if (!((0 <= part && part <= 0xffff))) {\n                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n                }\n            }\n\n            if (zoneId) {\n                this.zoneId = zoneId;\n            }\n        }\n\n        // Special IPv6 ranges\n        IPv6.prototype.SpecialRanges = {\n            // RFC4291, here and after\n            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n            linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n            multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n            uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n            // RFC6666\n            discard: [new IPv6([0x100, 0, 0, 0, 0, 0, 0, 0]), 64],\n            // RFC6145\n            rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n            // RFC6052\n            rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n            // RFC3056\n            '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n            // RFC6052, RFC6146\n            teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n            // RFC5180\n            benchmarking: [new IPv6([0x2001, 0x2, 0, 0, 0, 0, 0, 0]), 48],\n            // RFC7450\n            amt: [new IPv6([0x2001, 0x3, 0, 0, 0, 0, 0, 0]), 32],\n            as112v6: [\n                [new IPv6([0x2001, 0x4, 0x112, 0, 0, 0, 0, 0]), 48],\n                [new IPv6([0x2620, 0x4f, 0x8000, 0, 0, 0, 0, 0]), 48],\n            ],\n            deprecated: [new IPv6([0x2001, 0x10, 0, 0, 0, 0, 0, 0]), 28],\n            orchid2: [new IPv6([0x2001, 0x20, 0, 0, 0, 0, 0, 0]), 28],\n            droneRemoteIdProtocolEntityTags: [new IPv6([0x2001, 0x30, 0, 0, 0, 0, 0, 0]), 28],\n            reserved: [\n                // RFC3849\n                [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 23],\n                // RFC2928\n                [new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32],\n            ],\n        };\n\n        // Checks if this address is an IPv4-mapped IPv6 address.\n        IPv6.prototype.isIPv4MappedAddress = function () {\n            return this.range() === 'ipv4Mapped';\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv6.prototype.kind = function () {\n            return 'ipv6';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv6.prototype.match = function (other, cidrRange) {\n            let ref;\n\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv6') {\n                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n            }\n\n            return matchCIDR(this.parts, other.parts, 16, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv6 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv6.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 16,\n                32768: 15,\n                49152: 14,\n                57344: 13,\n                61440: 12,\n                63488: 11,\n                64512: 10,\n                65024: 9,\n                65280: 8,\n                65408: 7,\n                65472: 6,\n                65504: 5,\n                65520: 4,\n                65528: 3,\n                65532: 2,\n                65534: 1,\n                65535: 0\n            };\n            let part, zeros;\n\n            for (let i = 7; i >= 0; i -= 1) {\n                part = this.parts[i];\n                if (part in zerotable) {\n                    zeros = zerotable[part];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 16) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 128 - cidr;\n        };\n\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv6.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv6.prototype.toByteArray = function () {\n            let part;\n            const bytes = [];\n            const ref = this.parts;\n            for (let i = 0; i < ref.length; i++) {\n                part = ref[i];\n                bytes.push(part >> 8);\n                bytes.push(part & 0xff);\n            }\n\n            return bytes;\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:0db8:0008:0066:0000:0000:0000:0001\n        IPv6.prototype.toFixedLengthString = function () {\n            const addr = ((function () {\n                const results = [];\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(padPart(this.parts[i].toString(16), 4));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n        // Throws an error otherwise.\n        IPv6.prototype.toIPv4Address = function () {\n            if (!this.isIPv4MappedAddress()) {\n                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n            }\n\n            const ref = this.parts.slice(-2);\n            const high = ref[0];\n            const low = ref[1];\n\n            return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:db8:8:66:0:0:0:1\n        //\n        // Deprecated: use toFixedLengthString() instead.\n        IPv6.prototype.toNormalizedString = function () {\n            const addr = ((function () {\n                const results = [];\n\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(this.parts[i].toString(16));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n        IPv6.prototype.toRFC5952String = function () {\n            const regex = /((^|:)(0(:|$)){2,})/g;\n            const string = this.toNormalizedString();\n            let bestMatchIndex = 0;\n            let bestMatchLength = -1;\n            let match;\n\n            while ((match = regex.exec(string))) {\n                if (match[0].length > bestMatchLength) {\n                    bestMatchIndex = match.index;\n                    bestMatchLength = match[0].length;\n                }\n            }\n\n            if (bestMatchLength < 0) {\n                return string;\n            }\n\n            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // Calls toRFC5952String under the hood.\n        IPv6.prototype.toString = function () {\n            return this.toRFC5952String();\n        };\n\n        return IPv6;\n\n    })();\n\n    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 16) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Checks if a given string is formatted like IPv6 address.\n    ipaddr.IPv6.isIPv6 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks to see if string is a valid IPv6 Address\n    ipaddr.IPv6.isValid = function (string) {\n\n        // Since IPv6.isValid is always called first, this shortcut\n        // provides a substantial performance gain.\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            const addr = this.parser(string);\n            new this(addr.parts, addr.zoneId);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a valid IPv6 address in CIDR notation.\n    ipaddr.IPv6.isValidCIDR = function (string) {\n\n        // See note in IPv6.isValid\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 16) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Tries to parse and validate a string with IPv6 address.\n    // Throws an error if it fails.\n    ipaddr.IPv6.parse = function (string) {\n        const addr = this.parser(string);\n\n        if (addr.parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n        }\n\n        return new this(addr.parts, addr.zoneId);\n    };\n\n    ipaddr.IPv6.parseCIDR = function (string) {\n        let maskLength, match, parsed;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 128) {\n                parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n    };\n\n    // Parse an IPv6 address.\n    ipaddr.IPv6.parser = function (string) {\n        let addr, i, match, octet, octets, zoneId;\n\n        if ((match = string.match(ipv6Regexes.deprecatedTransitional))) {\n            return this.parser(`::ffff:${match[1]}`);\n        }\n        if (ipv6Regexes.native.test(string)) {\n            return expandIPv6(string, 8);\n        }\n        if ((match = string.match(ipv6Regexes.transitional))) {\n            zoneId = match[6] || '';\n            addr = match[1]\n            if (!match[1].endsWith('::')) {\n                addr = addr.slice(0, -1)\n            }\n            addr = expandIPv6(addr + zoneId, 6);\n            if (addr.parts) {\n                octets = [\n                    parseInt(match[2]),\n                    parseInt(match[3]),\n                    parseInt(match[4]),\n                    parseInt(match[5])\n                ];\n                for (i = 0; i < octets.length; i++) {\n                    octet = octets[i];\n                    if (!((0 <= octet && octet <= 255))) {\n                        return null;\n                    }\n                }\n\n                addr.parts.push(octets[0] << 8 | octets[1]);\n                addr.parts.push(octets[2] << 8 | octets[3]);\n                return {\n                    parts: addr.parts,\n                    zoneId: addr.zoneId\n                };\n            }\n        }\n\n        return null;\n    };\n\n    // A utility function to return subnet mask in IPv6 format given the prefix length\n    ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 128) {\n            throw new Error('ipaddr: invalid IPv6 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 16) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n    ipaddr.fromByteArray = function (bytes) {\n        const length = bytes.length;\n\n        if (length === 4) {\n            return new ipaddr.IPv4(bytes);\n        } else if (length === 16) {\n            return new ipaddr.IPv6(bytes);\n        } else {\n            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n        }\n    };\n\n    // Checks if the address is valid IP address\n    ipaddr.isValid = function (string) {\n        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n    };\n\n    // Checks if the address is valid IP address in CIDR notation\n    ipaddr.isValidCIDR = function (string) {\n        return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);\n    };\n\n\n    // Attempts to parse an IP Address, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parse = function (string) {\n        if (ipaddr.IPv6.isValid(string)) {\n            return ipaddr.IPv6.parse(string);\n        } else if (ipaddr.IPv4.isValid(string)) {\n            return ipaddr.IPv4.parse(string);\n        } else {\n            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n        }\n    };\n\n    // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parseCIDR = function (string) {\n        try {\n            return ipaddr.IPv6.parseCIDR(string);\n        } catch (e) {\n            try {\n                return ipaddr.IPv4.parseCIDR(string);\n            } catch (e2) {\n                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n            }\n        }\n    };\n\n    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n    ipaddr.process = function (string) {\n        const addr = this.parse(string);\n\n        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n            return addr.toIPv4Address();\n        } else {\n            return addr;\n        }\n    };\n\n    // An utility function to ease named range matching. See examples below.\n    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n    // on matching IPv4 addresses to IPv6 ranges or vice versa.\n    ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n        let i, rangeName, rangeSubnets, subnet;\n\n        if (defaultName === undefined || defaultName === null) {\n            defaultName = 'unicast';\n        }\n\n        for (rangeName in rangeList) {\n            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n                rangeSubnets = rangeList[rangeName];\n                // ECMA5 Array.isArray isn't available everywhere\n                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n                    rangeSubnets = [rangeSubnets];\n                }\n\n                for (i = 0; i < rangeSubnets.length; i++) {\n                    subnet = rangeSubnets[i];\n                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n                        return rangeName;\n                    }\n                }\n            }\n        }\n\n        return defaultName;\n    };\n\n    // Export for both the CommonJS and browser-like environment\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = ipaddr;\n\n    } else {\n        root.ipaddr = ipaddr;\n    }\n\n}(this));\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const DEBUG = 0;\nexport const INFO = 1;\nexport const WARN = 2;\nexport const ERROR = 3;\nexport const NONE = 4;\nexport let log_level = INFO;\n\nexport function get_timestamp() {\n  let [date, time] = new Date().toJSON().split(\"T\");\n  date = date.replaceAll(\"-\", \"/\");\n  time = time.split(\".\")[0];\n  return `[${date} - ${time}]`;\n}\n\nexport function set_level(level) {\n  log_level = level;\n}\n\nexport function debug(...messages) {\n  if (log_level > DEBUG) return;\n  console.debug(get_timestamp() + \" debug:\", ...messages);\n}\n\nexport function info(...messages) {\n  if (log_level > INFO) return;\n  console.info(get_timestamp() + \" info:\", ...messages);\n}\n\nexport function log(...messages) {\n  if (log_level > INFO) return;\n  console.log(get_timestamp() + \" log:\", ...messages);\n}\n\nexport function warn(...messages) {\n  if (log_level > WARN) return;\n  console.warn(get_timestamp() + \" warn:\", ...messages);\n}\n\nexport function error(...messages) {\n  if (log_level > ERROR) return;\n  console.error(get_timestamp() + \" error:\", ...messages);\n}\n\n","//shared packet parsing / serialization code\n\nconst text_encoder = new TextEncoder();\nconst encode_text = text_encoder.encode.bind(text_encoder);\nconst text_decoder = new TextDecoder();\nconst decode_text = text_decoder.decode.bind(text_decoder);\n\nexport class WispBuffer {\n  constructor(data) {\n    if (data instanceof Uint8Array) {\n      this.from_array(data);\n    }\n    else if (typeof data === \"number\") {\n      this.from_array(new Uint8Array(data));\n    }\n    else if (typeof data === \"string\") {\n      this.from_array(encode_text(data));\n    }\n    else {\n      console.trace();\n      throw \"invalid data type passed to wisp buffer constructor\";\n    }\n  }\n\n  from_array(bytes) {\n    this.size = bytes.length;\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer); \n  }\n\n  concat(buffer) {\n    let new_buffer = new WispBuffer(this.size + buffer.size);\n    new_buffer.bytes.set(this.bytes, 0);\n    new_buffer.bytes.set(buffer.bytes, this.size);\n    return new_buffer;\n  }\n\n  slice(index, size) {\n    let bytes_slice = this.bytes.slice(index, size);\n    return new WispBuffer(bytes_slice);\n  }\n\n  get_string() {\n    return text_decoder.decode(this.bytes);\n  }\n}\n\nexport class WispPacket {\n  static min_size = 5;\n  constructor({type, stream_id, payload, payload_bytes }) {\n    this.type = type;\n    this.stream_id = stream_id;\n    this.payload_bytes = payload_bytes;\n    this.payload = payload;\n  }\n  static parse(buffer) {\n    return new WispPacket({\n      type: buffer.view.getUint8(0),\n      stream_id: buffer.view.getUint32(1, true),\n      payload_bytes: buffer.slice(5)\n    });\n  }\n  static parse_all(buffer) {\n    if (buffer.size < WispPacket.min_size) {\n      throw TypeError(\"packet too small\");\n    }\n    let packet = WispPacket.parse(buffer);\n    let payload_class = packet_classes[packet.type];\n    if (typeof payload_class === \"undefined\") {\n      throw TypeError(\"invalid packet type\");\n    }\n    if (packet.payload_bytes.size < payload_class.size) {\n      throw TypeError(\"payload too small\");\n    }\n    packet.payload = payload_class.parse(packet.payload_bytes);\n    return packet;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    buffer.view.setUint8(0, this.type);\n    buffer.view.setUint32(1, this.stream_id, true);\n    buffer = buffer.concat(this.payload.serialize());\n    return buffer;\n  }\n}\n\nexport class ConnectPayload {\n  static min_size = 3;\n  static type = 0x01;\n  static name = \"CONNECT\";\n  constructor({stream_type, port, hostname}) {\n    this.stream_type = stream_type;\n    this.port = port;\n    this.hostname = hostname;\n  }\n  static parse(buffer) {\n    return new ConnectPayload({\n      stream_type: buffer.view.getUint8(0),\n      port: buffer.view.getUint16(1, true),\n      hostname: decode_text(buffer.slice(3).bytes)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(3);\n    buffer.view.setUint8(0, this.stream_type);\n    buffer.view.setUint16(1, this.port, true);\n    buffer = buffer.concat(new WispBuffer(this.hostname));\n    return buffer;\n  }\n}\n\nexport class DataPayload {\n  static min_size = 0;\n  static type = 0x02;\n  static name = \"DATA\";\n  constructor({data}) {\n    this.data = data;\n  }\n  static parse(buffer) {\n    return new DataPayload({\n      data: buffer\n    });\n  }\n  serialize() {\n    return this.data;\n  }\n}\n\nexport class ContinuePayload {\n  static type = 0x03;\n  static name = \"CONTINUE\";\n  constructor({buffer_remaining}) {\n    this.buffer_remaining = buffer_remaining;\n  }\n  static parse(buffer) {\n    return new ContinuePayload({\n      buffer_remaining: buffer.view.getUint32(0, true),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(4);\n    buffer.view.setUint32(0, this.buffer_remaining, true);\n    return buffer;\n  }\n}\n\nexport class ClosePayload {\n  static min_size = 1;\n  static type = 0x04;\n  static name = \"CLOSE\";\n  constructor({reason}) {\n    this.reason = reason;\n  }\n  static parse(buffer) {\n    return new ClosePayload({\n      reason: buffer.view.getUint8(0),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(1);\n    buffer.view.setUint8(0, this.reason);\n    return buffer;\n  }\n}\n\nexport class InfoPayload {\n  static min_size = 2;\n  static type = 0x05;\n  static name = \"INFO\";\n  constructor({major_ver, minor_ver, extensions}) {\n    this.major_ver = major_ver;\n    this.minor_ver = minor_ver;\n    this.extensions = extensions;\n  }\n  static parse(buffer) {\n    return new InfoPayload({\n      major_ver: buffer.view.getUint8(0),\n      minor_ver: buffer.view.getUint8(1),\n      extensions: buffer.slice(2)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(2);\n    buffer.view.setUint8(0, this.major_ver);\n    buffer.view.setUint8(1, this.minor_ver);\n    return buffer.concat(this.extensions);\n  }\n}\n\nexport const packet_classes = {\n  0x01: ConnectPayload, \n  0x02: DataPayload, \n  0x03: ContinuePayload, \n  0x04: ClosePayload,\n  0x05: InfoPayload\n}\n\nexport const packet_types = {\n  CONNECT: 0x01,\n  DATA: 0x02,\n  CONTINUE: 0x03,\n  CLOSE: 0x04,\n  INFO: 0x05\n}\n\nexport const stream_types = {\n  TCP: 0x01,\n  UDP: 0x02\n}\n\nexport const close_reasons = {\n  //client/server close reasons\n  Unknown: 0x01,\n  Voluntary: 0x02,\n  NetworkError: 0x03,\n  IncompatibleExtensions: 0x04,\n\n  //server only close reasons\n  InvalidInfo: 0x41, \n  UnreachableHost: 0x42,\n  NoResponse: 0x43,\n  ConnRefused: 0x44,\n  TransferTimeout: 0x47,\n  HostBlocked: 0x48,\n  ConnThrottled: 0x49,\n\n  //client only close reasons\n  ClientError: 0x81,\n\n  //extension specific close reasons\n  AuthBadPassword: 0xc0,\n  AuthBadSignature: 0xc1,\n  AuthMissingCredentials: 0xc2\n}","export const options = {\n  //destination hostname restrictions\n  hostname_blacklist: null,\n  hostname_whitelist: null,\n  port_blacklist: null,\n  port_whitelist: null,\n  allow_direct_ip: true,\n  allow_private_ips: false,\n  allow_loopback_ips: false,\n  \n  //client connection restrictions\n  client_ip_blacklist: null, //not implemented!\n  client_ip_whitelist: null, //not implemented!\n  stream_limit_per_host: -1,\n  stream_limit_total: -1,\n  allow_udp_streams: true,\n  allow_tcp_streams: true,\n\n  //dns options\n  dns_ttl: 120,\n  dns_method: \"lookup\",\n  dns_servers: null,\n  dns_result_order: \"verbatim\",\n\n  //misc options\n  parse_real_ip: true,\n  parse_real_ip_from: [\"127.0.0.1\"],\n\n  //wisp v2 options\n  wisp_version: 2,\n  wisp_motd: null\n}\n\n","//the node modules referenced by other parts of the code do not exist on the web\n//some of them can be replaced by the standard browser apis, others have to be ignored\n\n//compatibility for old browsers where globalThis doesn't exist\nexport const global_this = typeof globalThis === \"undefined\" ? window : globalThis;\n\nexport const WebSocket = global_this.WebSocket;\nexport const crypto = global_this.crypto;\nexport const WebSocketServer = null;\nexport const net = null;\nexport const dgram = null;\nexport const dns = null;\nexport const http = null;","//async websocket wrapper for both node and the browser\n\nimport * as compat from \"./compat.mjs\";\nimport { WispPacket } from \"./packet.mjs\";\n\nexport function get_conn_id() {\n  return compat.crypto.randomUUID().split(\"-\")[0];\n}\n\n//an async websocket wrapper\nexport class AsyncWebSocket {\n  send_buffer_size = 32*1024*1024;\n  \n  constructor(ws) {\n    this.ws = ws;\n    this.connected = false;\n    this.data_queue = new AsyncQueue(1);\n  }\n\n  async connect() {\n    await new Promise((resolve, reject) => {\n      this.ws.onopen = () => {\n        this.connected = true;\n        resolve();\n      }\n      this.ws.onmessage = (event) => {\n        this.data_queue.put(event.data);\n      }\n      this.ws.onclose = () => {\n        if (!this.connected) reject();\n        else this.data_queue.close();\n      }\n      if (this.ws.readyState === this.ws.OPEN) {\n        this.connected = true;\n        resolve();\n      }\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    if (data instanceof WispPacket) {\n      data = data.serialize().bytes\n    }\n\n    this.ws.send(data);\n    if (this.ws.bufferedAmount <= this.send_buffer_size) {\n      return;\n    }\n\n    //if the send buffer is too full, throttle the upload\n    while (true) {\n      if (this.ws.bufferedAmount <= this.send_buffer_size / 2) {\n        break;\n      }\n      await new Promise((resolve) => {setTimeout(resolve, 10)});\n    }\n  }\n\n  close(code, reason) {\n    this.ws.close(code, reason);\n    this.data_queue.close();\n  }\n\n  get buffered_amount() {\n    return this.ws.bufferedAmount;\n  }\n}\n\n//an async fifo queue\nexport class AsyncQueue {\n  constructor(max_size) {\n    this.max_size = max_size;\n    this.queue = [];\n    this.put_callbacks = [];\n    this.get_callbacks = [];\n  }\n\n  put_now(data) {\n    this.queue.push(data);\n    this.get_callbacks.shift()?.();\n  }\n\n  async put(data) {\n    if (this.size <= this.max_size) {\n      this.put_now(data);\n      return;\n    }\n\n    //wait until there is a place to put the item\n    await new Promise((resolve) => {\n      this.put_callbacks.push(resolve);\n    });\n    this.put_now(data);\n  }\n\n  get_now() {\n    this.put_callbacks.shift()?.();\n    return this.queue.shift();\n  }\n\n  async get() {\n    if (this.size > 0) {\n      return this.get_now();\n    }\n\n    //wait until there is an item available in the queue\n    await new Promise((resolve) => {\n      this.get_callbacks.push(resolve);\n    });\n    return this.get_now();\n  }\n\n  close() {\n    this.queue = [];\n    let callback;\n    //resolve all pending operations\n    while (callback = this.get_callbacks.shift())\n      callback();\n    while (callback = this.put_callbacks.shift())\n      callback();\n  }\n\n  get size() {\n    return this.queue.length;\n  }\n}","import * as logging from \"../logging.mjs\";\nimport { AsyncQueue } from \"../websocket.mjs\";\nimport { options } from \"./options.mjs\";\nimport { net, dgram, dns } from \"../compat.mjs\";\n\n//wrappers for node networking apis\n//in the browser these can be redefined to allow for custom transports\n\nexport const is_node = (typeof process !== \"undefined\");\n\nconst dns_cache = new Map();\nlet dns_servers = null;\nlet resolver = null;\n\nexport function assert_on_node() {\n  if (!is_node) {\n    throw new Error(\"not running on node.js\");\n  }\n}\n\n//wrapper for node resolver methods\n//resolve4 and resolve6 need to be wrapped to work around a nodejs bug\nfunction resolve4(hostname) {\n  return resolver.resolve4(hostname);\n}\nfunction resolve6(hostname) {\n  return resolver.resolve6(hostname);\n}\nasync function resolve_with_fallback(resolve_first, resolve_after, hostname) {\n  try {\n    return (await resolve_first(hostname))[0];\n  }\n  catch {\n    return (await resolve_after(hostname))[0];\n  }\n}  \n\n//a wrapper for the actual dns lookup\nasync function perform_lookup(hostname) {\n  //resolve using system dns\n  if (options.dns_method === \"lookup\") {\n    let result = await dns.lookup(hostname, {order: options.dns_result_order}); \n    return result.address;\n  }\n\n  //resolve using dns.resolve4 / dns.resolve6, which bypasses the system dns\n  else if (options.dns_method === \"resolve\") {\n    //we need to make a new resolver at first run because setServers doesn't work otherwise\n    if (!resolver) resolver = new dns.Resolver();\n\n    //set custom dns servers if needed\n    if (options.dns_servers !== dns_servers) {\n      logging.debug(\"Setting custom DNS servers to: \" + options.dns_servers.join(\", \"));\n      resolver.setServers(options.dns_servers);\n      dns_servers = options.dns_servers;\n    }\n\n    if (options.dns_result_order === \"verbatim\" || options.dns_result_order === \"ipv6first\") \n      return await resolve_with_fallback(resolve6, resolve4, hostname);\n    else if (options.dns_result_order === \"ipv4first\")\n      return await resolve_with_fallback(resolve4, resolve6, hostname);\n    else\n      throw new Error(\"Invalid result order. options.dns_result_order must be either 'ipv6first', 'ipv4first', or 'verbatim'.\");\n  }\n\n  //use a custom function for dns resolution\n  else if (typeof options.dns_method === \"function\") {\n    return await options.dns_method(hostname);\n  }\n\n  throw new Error(\"Invalid DNS method. options.dns_method must either be 'lookup' or 'resolve'.\");\n}\n\n//perform a dns lookup and use the cache\nexport async function lookup_ip(hostname) {\n  if (!is_node) { //we cannot do the dns lookup on the browser\n    return hostname;\n  }\n\n  let ip_level = net.isIP(hostname);\n  if (ip_level === 4 || ip_level === 6) {\n    return hostname; //hostname is already an ip address\n  }\n\n  //remove stale entries from the cache\n  let now = Date.now();\n  for (let [entry_hostname, cache_entry] of dns_cache) {\n    let ttl = now - cache_entry.time;\n    if (ttl > options.dns_ttl) {\n      dns_cache.delete(entry_hostname);\n    }\n  }\n\n  //look in the cache first before using the system resolver\n  let cache_entry = dns_cache.get(hostname);\n  if (cache_entry) {\n    if (cache_entry.error) \n      throw cache_entry.error\n    return cache_entry.address;\n  }\n\n  //try to perform the actual dns lookup and store the result\n  let address;\n  try {\n    address = await perform_lookup(hostname);\n    logging.debug(`Domain resolved: ${hostname} -> ${address}`);\n    dns_cache.set(hostname, {time: Date.now(), address: address});\n  }\n  catch (e) {\n    dns_cache.set(hostname, {time: Date.now(), error: e});\n    throw e;\n  }\n\n  return address;\n}\n\n//async tcp and udp socket wrappers\nexport class NodeTCPSocket {\n  constructor(hostname, port) {\n    assert_on_node();\n    this.hostname = hostname;\n    this.port = port;\n    this.recv_buffer_size = 128;\n\n    this.socket = null;\n    this.paused = false;\n    this.connected = false;\n    this.data_queue = new AsyncQueue(this.recv_buffer_size);\n  }\n\n  async connect() {\n    let ip = await lookup_ip(this.hostname);\n    await new Promise((resolve, reject) => {\n      this.socket = new net.Socket();\n      this.socket.setNoDelay(true);\n      this.socket.on(\"connect\", () => {\n        this.connected = true;\n        resolve();\n      });\n      this.socket.on(\"data\", (data) => {\n        this.data_queue.put(data);\n      });\n      this.socket.on(\"close\", (error) => {\n        if (error && !this.connected) reject();\n        else this.data_queue.close();\n        this.socket = null;\n      });\n      this.socket.on(\"error\", (error) => {\n        logging.warn(`tcp stream to ${this.hostname} ended with error - ${error}`);\n      });\n      this.socket.on(\"end\", () => {\n        if (!this.socket) return;\n        this.socket.destroy();\n        this.socket = null;\n      });\n      this.socket.connect({\n        host: ip,\n        port: this.port\n      });\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    await new Promise((resolve) => {\n      this.socket.write(data, resolve);\n    });\n  }\n\n  async close() {\n    if (!this.socket) return;\n    this.socket.end();\n    this.socket = null;\n  }\n\n  pause() {\n    if (this.data_queue.size >= this.data_queue.max_size) {\n      this.socket.pause();\n      this.paused = true;\n    }\n  }\n  resume() {\n    if (!this.socket) return;\n    if (this.paused) {\n      this.socket.resume();\n      this.paused = false;\n    }\n  }\n}\n\nexport class NodeUDPSocket {\n  constructor(hostname, port) {\n    assert_on_node();\n    this.hostname = hostname;\n    this.port = port;\n\n    this.connected = false;\n    this.recv_buffer_size = 128;\n    this.data_queue = new AsyncQueue(this.recv_buffer_size);\n  }\n\n  async connect() {\n    let ip = await lookup_ip(this.hostname);\n    let ip_level = net.isIP(ip);\n    await new Promise((resolve, reject) => {\n      this.socket = dgram.createSocket(ip_level === 6 ? \"udp6\" : \"udp4\");\n      this.socket.on(\"connect\", () => {\n        resolve();\n      });\n      this.socket.on(\"message\", (data) => {\n        this.data_queue.put(data);\n      });\n      this.socket.on(\"error\", () => {\n        if (!this.connected) reject();\n        this.data_queue.close();\n        this.socket = null;\n      });\n      this.socket.connect(this.port, ip);\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    this.socket.send(data);\n  }\n\n  async close() {\n    if (!this.socket) return;\n    this.socket.close();\n    this.socket = null;\n  }\n\n  pause() {}\n  resume() {}\n}","import { close_reasons, stream_types } from \"../packet.mjs\";\nimport { options } from \"./options.mjs\";\nimport * as net from \"./net.mjs\";\n\nimport ipaddr from \"ipaddr.js\";\n\nexport class AccessDeniedError extends Error {}\n\n//helper functions for the whitelist/blacklist logic\nfunction check_port_range(entry, port) {\n  return (entry === port) || (entry[0] <= port && entry[1] >= port)\n}\nfunction check_whitelist(entries, filter) {\n  let matched = false;\n  for (let entry of entries) {\n    if (filter(entry)) {\n      matched = true;\n      break\n    }\n  }\n  return !matched;\n}\nfunction check_blacklist(entries, filter) {\n  for (let entry of entries) {\n    if (filter(entry))\n      return true;\n    }\n  return false;\n}\n\nfunction check_ip_range(ip, range) {\n  return range.includes(ip.range());\n}\n\n//check if an ip is blocked\nexport function is_ip_blocked(ip_str) {\n  if (!ipaddr.isValid(ip_str)) \n    return false;\n  let ip = ipaddr.parse(ip_str);\n\n  let loopback_ranges = [\"loopback\", \"unspecified\"];\n  let private_ranges = [\"broadcast\", \"linkLocal\", \"carrierGradeNat\", \"private\", \"reserved\"];\n\n  if (!options.allow_loopback_ips && check_ip_range(ip, loopback_ranges)) \n    return true;\n  if (!options.allow_private_ips && check_ip_range(ip, private_ranges)) \n    return true;\n  return false;\n}\n\n//returns the close reason if the connection should be blocked\nexport async function is_stream_allowed(connection, type, hostname, port) {\n  //check if tcp or udp should be blocked\n  if (!options.allow_tcp_streams && type === stream_types.TCP)\n    return close_reasons.HostBlocked;\n  if (!options.allow_udp_streams && type === stream_types.UDP)\n    return close_reasons.HostBlocked;\n\n  //check the hostname whitelist/blacklist\n  if (options.hostname_whitelist) {\n    if (check_whitelist(options.hostname_whitelist, (entry) => entry.test(hostname)))\n      return close_reasons.HostBlocked;\n  }\n  else if (options.hostname_blacklist) {\n    if (check_blacklist(options.hostname_blacklist, (entry) => entry.test(hostname)))\n      return close_reasons.HostBlocked;\n  }\n\n  //check if the port is blocked\n  if (options.port_whitelist) {\n    if (check_whitelist(options.port_whitelist, (entry) => check_port_range(entry, port))) \n      return close_reasons.HostBlocked;\n  }\n  else if (options.port_blacklist) {\n    if (check_blacklist(options.port_blacklist, (entry) => check_port_range(entry, port)))\n      return close_reasons.HostBlocked;\n  }\n\n  //check if the destination ip is blocked\n  let ip_str = hostname;\n  if (ipaddr.isValid(hostname)) {\n    if (!options.allow_direct_ip)\n      return close_reasons.HostBlocked;\n  }\n  else {\n    try { //look up the ip to make sure that the resolved address is allowed\n      ip_str = await net.lookup_ip(hostname);\n    }\n    catch {}\n  }\n  if (is_ip_blocked(ip_str)) \n    return close_reasons.HostBlocked;\n\n  //don't check stream counts if there isn't an associated wisp connection (with wsproxy for example)\n  if (!connection) \n    return 0;\n\n  //check for stream count limits\n  if (options.stream_limit_total !== -1 && Object.keys(connection.streams).length >= options.stream_limit_total) \n    return close_reasons.ConnThrottled;\n  if (options.stream_limit_per_host !== -1) {\n    let streams_per_host = 0;\n    for (let stream of connection.streams) {\n      if (stream.socket.hostname === hostname) {\n        streams_per_host++;\n      }\n    }\n    if (streams_per_host >= options.stream_limit_per_host)\n      return close_reasons.ConnThrottled;\n  }\n\n  return 0;\n}","import { WispBuffer } from \"./packet.mjs\";\n\nclass EmptyPayload {\n  constructor() {}\n  static parse() {\n    return new EmptyPayload();\n  }\n  serialize() {\n    return new WispBuffer(0);\n  }\n}\n\nexport class BaseExtension {\n  static id = 0x00;\n  static name = \"\";\n\n  static Server = EmptyPayload;\n  static Client = EmptyPayload;\n\n  constructor({server_config, client_config} = {}) {\n    this.id = this.constructor.id;\n    this.name = this.constructor.name;\n    if (server_config)\n      this.payload = new this.constructor.Server(server_config);\n    else if (client_config)\n      this.payload = new this.constructor.Client(client_config);\n  }\n  static parse(ext_class, buffer, role) {\n    let extension = new ext_class({});\n    if (role === \"client\")\n      extension.payload = ext_class.Client.parse(buffer.slice(5));\n    else if (role === \"server\")\n      extension.payload = ext_class.Server.parse(buffer.slice(5));\n    else \n      throw TypeError(\"invalid role\");\n    return extension;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    let payload_buffer = this.payload.serialize();\n    buffer.view.setInt8(0, this.constructor.id);\n    buffer.view.setUint32(1, payload_buffer.size, true);\n    return buffer.concat(payload_buffer);\n  }\n}\n\nexport class UDPExtension extends BaseExtension {\n  static id = 0x01;\n  static name = \"UDP\";\n}\n\nexport class PasswordAuthExtension extends BaseExtension {\n  static id = 0x02;\n  static name = \"Password Authentication\";\n\n  static Server = class {\n    constructor({required = 1}) {\n      this.required = required ? 1 : 0;\n    }\n    static parse(buffer) {\n      return new PasswordAuthExtension.Server({\n        required: buffer.view.getUint8(0)\n      });\n    }\n    serialize() {\n      let buffer = new WispBuffer(1);\n      buffer.view.setUint8(0, this.required);\n      return buffer;\n    }\n  }\n\n  static Client = class {\n    constructor({username, password}) {\n      this.username = username;\n      this.password = password;\n    }\n    static parse(buffer) {\n      let username_len = buffer.view.getUint8(0);\n      let password_len = buffer.view.getUint16(1, true);\n      let password_index = username_len + 3;\n      return new PasswordAuthExtension.Client({\n        username: buffer.slice(3, username_len).get_string(),\n        password: buffer.slice(password_index, password_len).get_string()\n      });\n    }\n    serialize() {\n      let username_buffer = new WispBuffer(this.username);\n      let password_buffer = new WispBuffer(this.password);\n      let buffer = new WispBuffer(3);\n      buffer.view.setUint8(0, username_buffer.size);\n      buffer.view.setUint16(1, password_buffer.size, true);\n      return buffer.concat(username_buffer).concat(password_buffer);\n    }\n  }\n}\n\nexport class MOTDExtension extends BaseExtension {\n  static id = 0x04;\n  static name = \"Server MOTD\";\n\n  static Server = class {\n    constructor({message}) {\n      this.message = message;\n    }\n    static parse(buffer) {\n      return new MOTDExtension.Server({\n        message: buffer.get_string()\n      });\n    }\n    serialize() {\n      return new WispBuffer(this.message);\n    }\n  }\n\n  static Client = EmptyPayload;\n}\n\nexport function parse_extensions(payload_buffer, valid_extensions, role) {\n  let index = 0;\n  let parsed_extensions = [];\n  while (payload_buffer.size) {\n    let ext_id = payload_buffer.view.getUint8(index);\n    let ext_len = payload_buffer.view.getUint32(index + 1, true);\n    let ext_payload = payload_buffer.slice(0, 5 + ext_len);\n    let ext_class;\n    for (let extension of valid_extensions) {\n      if (extension.id !== ext_id) \n        continue;\n      ext_class = extension.constructor;\n      break;\n    }\n    if (ext_class) {\n      let ext_parsed = BaseExtension.parse(ext_class, ext_payload, role);\n      parsed_extensions.push(ext_parsed);\n    }\n    payload_buffer = payload_buffer.slice(5 + ext_len);\n  }\n  return parsed_extensions;\n}\n\nexport function serialize_extensions(extensions) {{\n  let ext_buffer = new WispBuffer(0);\n  for (let extension of extensions) {\n    ext_buffer = ext_buffer.concat(extension.serialize());\n  }\n  return ext_buffer;\n}}\n\nexport const extensions_map = {\n  0x01: UDPExtension,\n  0x02: PasswordAuthExtension,\n  0x04: MOTDExtension\n}","import * as logging from \"../logging.mjs\";\nimport * as filter from \"./filter.mjs\";\nimport { AsyncQueue, AsyncWebSocket, get_conn_id } from \"../websocket.mjs\";\nimport { NodeTCPSocket, NodeUDPSocket } from \"./net.mjs\";\nimport { \n  WispBuffer,\n  WispPacket,\n  ContinuePayload,\n  ClosePayload,\n  ConnectPayload,\n  DataPayload,\n  InfoPayload,\n  stream_types,\n  close_reasons\n} from \"../packet.mjs\";\nimport { options } from \"./options.mjs\";\nimport { MOTDExtension, UDPExtension, serialize_extensions, parse_extensions } from \"../extensions.mjs\";\n\nexport class HandshakeError extends Error {}\n\nexport class ServerStream {\n  static buffer_size = 128;\n\n  constructor(stream_id, conn, socket) {\n    this.stream_id = stream_id;\n    this.conn = conn;\n    this.socket = socket;    \n    this.send_buffer = new AsyncQueue(ServerStream.buffer_size);\n    this.packets_sent = 0;\n  }\n\n  async setup() {\n    await this.socket.connect();\n\n    //start the proxy tasks in the background\n    this.tcp_to_ws().catch((error) => {\n      logging.error(`(${this.conn.conn_id}) a tcp/udp to ws task encountered an error - ${error}`);\n      this.close();\n    });\n    this.ws_to_tcp().catch((error) => {\n      logging.error(`(${this.conn.conn_id}) a ws to tcp/udp task encountered an error - ${error}`);\n      this.close();\n    });\n  }\n\n  async tcp_to_ws() {\n    while (true) {\n      let data = await this.socket.recv();\n      if (data == null) {\n        break;\n      }\n\n      this.socket.pause();\n      let packet = new WispPacket({\n        type: DataPayload.type,\n        stream_id: this.stream_id,\n        payload: new DataPayload({\n          data: new WispBuffer(new Uint8Array(data))\n        })\n      });\n      await this.conn.ws.send(packet);\n      this.socket.resume();\n    }\n    await this.conn.close_stream(this.stream_id, close_reasons.Voluntary);\n  }\n\n  async ws_to_tcp() {\n    while (true) {\n      let data = await this.send_buffer.get();\n      if (data == null) {\n        break; //stream closed\n      }\n      await this.socket.send(data);\n\n      this.packets_sent++;\n      if (this.packets_sent % (ServerStream.buffer_size / 2) !== 0) {\n        continue;\n      }\n      let packet = new WispPacket({\n        type: ContinuePayload.type,\n        stream_id: this.stream_id,\n        payload: new ContinuePayload({\n          buffer_remaining: ServerStream.buffer_size - this.send_buffer.size\n        })\n      });\n      this.conn.ws.send(packet);\n    }\n    await this.close();\n  }\n\n  async close(reason = null) {\n    this.send_buffer.close();\n    this.socket.close();\n    if (reason == null) return;\n\n    let packet = new WispPacket({\n      type: ClosePayload.type,\n      stream_id: this.stream_id,\n      payload: new ClosePayload({\n        reason: reason\n      })\n    });\n    await this.conn.ws.send(packet);\n  }\n\n  async put_data(data) {\n    await this.send_buffer.put(data);\n  }\n}\n\nexport class ServerConnection {\n  constructor(ws, path, {TCPSocket, UDPSocket, ping_interval, wisp_version, wisp_extensions} = {}) {\n    this.ws = new AsyncWebSocket(ws);\n    this.path = path;\n    this.TCPSocket = TCPSocket || NodeTCPSocket;\n    this.UDPSocket = UDPSocket || NodeUDPSocket;\n    this.ping_interval = ping_interval || 30;\n    this.wisp_version = wisp_version || options.wisp_version;\n    this.wisp_extensions = wisp_extensions || null;\n    \n    this.ping_task = null;\n    this.streams = {};\n    this.conn_id = get_conn_id();\n\n    this.server_exts = {};\n    this.client_exts = {};\n\n    if (this.wisp_version === 2 && this.wisp_extensions === null) {\n      this.add_extensions();\n    }\n  }\n\n  add_extensions() {\n    this.wisp_extensions = [];\n    if (options.allow_udp_streams) \n      this.wisp_extensions.push(new UDPExtension({server_config: {}}));\n    if (options.wisp_motd)\n      this.wisp_extensions.push(new MOTDExtension({server_config: {\n        message: options.wisp_motd\n      }}));\n  }\n\n  async setup() {\n    logging.info(`setting up new wisp v${this.wisp_version} connection with id ${this.conn_id}`);\n\n    await this.ws.connect();\n    if (this.wisp_version == 2) {\n      await this.setup_wisp_v2()\n    }\n\n    //send initial continue packet\n    let continue_packet = new WispPacket({\n      type: ContinuePayload.type,\n      stream_id: 0,\n      payload: new ContinuePayload({\n        buffer_remaining: ServerStream.buffer_size\n      })\n    });\n    this.ws.send(continue_packet);\n\n    if (typeof this.ws.ws.ping === \"function\") {\n      this.ping_task = setInterval(() => {\n        logging.debug(`(${this.conn_id}) sending websocket ping`);\n        this.ws.ws.ping();\n      }, this.ping_interval * 1000);  \n    }\n  }\n\n  async setup_wisp_v2() {\n    //send initial info packet for wisp v2\n    let ext_buffer = serialize_extensions(this.wisp_extensions);\n    let info_packet = new WispPacket({\n      type: InfoPayload.type,\n      stream_id: 0,\n      payload: new InfoPayload({\n        major_ver: this.wisp_version,\n        minor_ver: 0,\n        extensions: ext_buffer\n      })\n    });\n    this.ws.send(info_packet);\n\n    //wait for the client's info packet\n    let data = await this.ws.recv();\n    if (data == null) {\n      logging.warn(`(${this.conn_id}) handshake error: ws closed before handshake complete`);\n      await this.cleanup();\n      throw new HandshakeError();\n    }\n    let buffer = new WispBuffer(new Uint8Array(data));\n    let packet = WispPacket.parse_all(buffer);\n\n    if (packet.type !== InfoPayload.type) {\n      logging.warn(`(${this.conn_id}) handshake error: unexpected packet of type ${packet.type}`);\n      await this.cleanup();\n      throw new HandshakeError();\n    }\n\n    //figure out the common extensions\n    let client_extensions = parse_extensions(packet.payload.extensions, this.wisp_extensions, \"client\");\n    for (let client_ext of client_extensions) {\n      for (let server_ext of this.wisp_extensions) {\n        if (server_ext.id === client_ext.id) {\n          this.server_exts[server_ext.id] = server_ext;\n          this.client_exts[client_ext.id] = client_ext;\n        }\n      }\n    }\n  }\n\n  create_stream(stream_id, type, hostname, port) {\n    let SocketImpl = type === stream_types.TCP ? this.TCPSocket : this.UDPSocket;\n    let socket = new SocketImpl(hostname, port);\n    let stream = new ServerStream(stream_id, this, socket);\n    this.streams[stream_id] = stream;\n\n    //start connecting to the destination server in the background\n    (async () => {\n      let close_reason = await filter.is_stream_allowed(this, type, hostname, port);\n      if (close_reason) {\n        logging.warn(`(${this.conn_id}) refusing to create a stream to ${hostname}:${port}`);\n        await this.close_stream(stream_id, close_reason, true);\n        return;\n      }\n      try {\n        await stream.setup();\n      }\n      catch (error) {\n        logging.warn(`(${this.conn_id}) creating a stream to ${hostname}:${port} failed - ${error}`);\n        await this.close_stream(stream_id, close_reasons.NetworkError);\n      }\n    })();\n  }\n\n  async close_stream(stream_id, reason = null, quiet = false) {\n    let stream = this.streams[stream_id];\n    if (stream == null) {\n      return;\n    }\n    if (reason && !quiet) {\n      logging.info(`(${this.conn_id}) closing stream to ${stream.socket.hostname} for reason ${reason}`);\n    }\n    await stream.close(reason);\n    delete this.streams[stream_id];\n  }\n\n  route_packet(buffer) {\n    let packet = WispPacket.parse_all(buffer);\n    let stream = this.streams[packet.stream_id];\n\n    if (stream == null && packet.type == DataPayload.type) {\n      logging.warn(`(${this.conn_id}) received a DATA packet for a stream which doesn't exist`);\n      return;\n    }\n\n    if (packet.type === ConnectPayload.type) {\n      let type_info = packet.payload.stream_type === stream_types.TCP ? \"TCP\" : \"UDP\";\n      logging.info(`(${this.conn_id}) opening new ${type_info} stream to ${packet.payload.hostname}:${packet.payload.port}`);\n      this.create_stream(\n        packet.stream_id, \n        packet.payload.stream_type, \n        packet.payload.hostname.trim(), \n        packet.payload.port\n      )\n    }\n\n    else if (packet.type === DataPayload.type) {\n      stream.put_data(packet.payload.data.bytes);\n    }\n\n    else if (packet.type == ContinuePayload.type) {\n      logging.warn(`(${this.conn_id}) client sent a CONTINUE packet, this should never be possible`);\n    }\n\n    else if (packet.type == ClosePayload.type) {\n      this.close_stream(packet.stream_id, packet.reason);\n    }\n  }\n\n  async run() {\n    while (true) {\n      let data;\n      data = await this.ws.recv();\n      if (data == null) {\n        break; //websocket closed\n      }\n      if (typeof data === \"string\") {\n        logging.warn(`(${this.conn_id}) routing a packet failed - unexpected ws text frame`);\n        continue;\n      }\n      \n      try {\n        //note: data is an arraybuffer so the uint8array constructor does not copy\n        this.route_packet(new WispBuffer(new Uint8Array(data)));\n      }\n      catch (error) {\n        logging.warn(`(${this.conn_id}) routing a packet failed - ${error}`);\n      }\n    }\n    \n    await this.cleanup();\n  }\n\n  async cleanup() {\n    //clean up all streams when the websocket is closed\n    for (let stream_id of Object.keys(this.streams)) {\n      await this.close_stream(stream_id);\n    }\n    clearInterval(this.ping_task);\n    logging.info(`(${this.conn_id}) wisp connection closed`);\n    this.ws.close();\n  }\n}","import * as logging from \"../logging.mjs\";\nimport * as filter from \"./filter.mjs\";\nimport { stream_types } from \"../packet.mjs\";\nimport { AsyncWebSocket } from \"../websocket.mjs\";\nimport { NodeTCPSocket } from \"./net.mjs\";\n\nexport class WSProxyConnection {\n  constructor(ws, path) {\n    let [hostname, port] = path.split(\"/\").pop().split(\":\");\n    this.hostname = hostname.trim();\n    this.port = parseInt(port);\n    this.ws = new AsyncWebSocket(ws);\n  }\n\n  async setup() {\n    await this.ws.connect();\n\n    //check that the destination host/ip is allowed\n    let err_code = await filter.is_stream_allowed(null, stream_types.TCP, this.hostname, this.port);\n    if (err_code !== 0) {\n      logging.info(`Refusing to create a wsproxy connection to ${this.hostname}:${this.port}`);\n      this.ws.close();\n      throw new filter.AccessDeniedError();\n    }\n\n    //connect to the tcp host after we are certain that it's safe to do so\n    this.socket = new NodeTCPSocket(this.hostname, this.port);\n    await this.socket.connect();\n\n    //start the proxy tasks in the background\n    this.tcp_to_ws().catch((error) => {\n      logging.error(`a tcp to ws task (wsproxy) encountered an error - ${error}`);\n    });\n    this.ws_to_tcp().catch((error) => {\n      logging.error(`a ws to tcp task (wsproxy) encountered an error - ${error}`);\n    });\n  }\n\n  async tcp_to_ws() {\n    while (true) {\n      let data = await this.socket.recv();\n      if (data == null) {\n        break;\n      }\n      this.socket.pause();\n      await this.ws.send(data);\n      this.socket.resume();\n    }\n    await this.ws.close();\n  }\n\n  async ws_to_tcp() {\n    while (true) {\n      let data;\n      data = await this.ws.recv();\n      if (data == null) {\n        break; //websocket closed\n      }\n      await this.socket.send(data);\n    }\n    await this.socket.close();\n  }\n}","import * as logging from \"../logging.mjs\";\nimport * as compat from \"../compat.mjs\";\n\nimport { options } from \"./options.mjs\";\nimport { AccessDeniedError } from \"./filter.mjs\";\nimport { ServerConnection, HandshakeError } from \"./connection.mjs\";\nimport { WSProxyConnection } from \"./wsproxy.mjs\";\nimport { is_node, assert_on_node } from \"./net.mjs\";\n\nlet ws_server = null;\nif (is_node) {\n  ws_server = new compat.WebSocketServer({ noServer: true });\n}\n\nexport function parse_real_ip(headers, client_ip) {\n  if (options.parse_real_ip && options.parse_real_ip_from.includes(client_ip)) {\n    if (headers[\"x-forwarded-for\"]) {\n      return headers[\"x-forwarded-for\"].split(\",\")[0].trim();\n    }\n    else if (headers[\"x-real-ip\"]) {\n      return headers[\"x-real-ip\"];\n    }\n  }\n  return client_ip;\n}\n\nexport function routeRequest(request, socket, head, conn_options={}) {\n  assert_on_node();\n  if (request.headers[\"sec-websocket-protocol\"] && options.wisp_version === 2)\n    conn_options.wisp_version = 2;\n  else \n    conn_options.wisp_version = 1;\n\n  if (request instanceof compat.http.IncomingMessage) {\n    ws_server.handleUpgrade(request, socket, head, (ws) => {\n      create_connection(ws, request.url, request, conn_options);\n    });\n  }\n  else if (request instanceof compat.WebSocket) {\n    create_connection(ws, \"/\", {}), conn_options;\n  }\n}\n\nasync function create_connection(ws, path, request, conn_options) {\n  ws.binaryType = \"arraybuffer\";\n  let client_ip = request.socket.address().address;\n  let real_ip = parse_real_ip(request.headers, client_ip);\n  let origin = request.headers[\"origin\"];\n  logging.info(`new connection on ${path} from ${real_ip} (origin: ${origin})`);\n  \n  try {\n    if (path.endsWith(\"/\")) {\n      let wisp_conn = new ServerConnection(ws, path, conn_options);\n      await wisp_conn.setup();\n      await wisp_conn.run();\n    }\n  \n    else {\n      let wsproxy = new WSProxyConnection(ws, path, conn_options);\n      await wsproxy.setup();\n    }\n  }\n\n  catch (error) {\n    ws.close();\n    if (error instanceof HandshakeError) return;\n    if (error instanceof AccessDeniedError) return;\n    logging.error(\"Uncaught server error:\\n\" + (error.stack || error));\n  }\n}"],"names":["root","ipv4Part","ipv4Regexes","fourOctet","RegExp","threeOctet","twoOctet","longValue","octalRegex","hexRegex","zoneIndex","ipv6Part","ipv6Regexes","deprecatedTransitional","transitional","expandIPv6","string","parts","indexOf","lastIndexOf","replacement","replacementCount","colonCount","lastColon","zoneId","match","substring","replace","substr","slice","length","ref","split","results","i","push","parseInt","matchCIDR","first","second","partSize","cidrBits","Error","shift","part","parseIntAuto","test","isNaN","padPart","ipaddr","IPv4","octets","octet","this","prototype","SpecialRanges","unspecified","broadcast","multicast","linkLocal","loopback","carrierGradeNat","reserved","as112","amt","kind","other","cidrRange","undefined","prefixLengthFromSubnetMask","cidr","stop","zerotable","zeros","range","subnetMatch","toByteArray","toIPv4MappedAddress","IPv6","parse","toString","toNormalizedString","join","broadcastAddressFromCIDR","parseCIDR","ipInterfaceOctets","subnetMaskOctets","subnetMaskFromPrefixLength","e","isIPv4","parser","isValid","isValidCIDR","isValidFourPartDecimal","networkAddressFromCIDR","maskLength","parsed","Object","defineProperty","value","reverse","prefix","j","filledOctetCount","Math","floor","pow","uniqueLocal","ipv4Mapped","discard","rfc6145","rfc6052","teredo","benchmarking","as112v6","deprecated","orchid2","droneRemoteIdProtocolEntityTags","isIPv4MappedAddress","bytes","toFixedLengthString","addr","call","suffix","toIPv4Address","high","low","toRFC5952String","regex","bestMatchIndex","bestMatchLength","exec","index","isIPv6","native","endsWith","fromByteArray","e2","process","address","rangeList","defaultName","rangeName","rangeSubnets","subnet","hasOwnProperty","Array","apply","module","exports","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","key","o","enumerable","get","obj","prop","r","Symbol","toStringTag","DEBUG","INFO","WARN","ERROR","NONE","log_level","get_timestamp","date","time","Date","toJSON","replaceAll","set_level","level","debug","messages","console","info","log","warn","error","text_encoder","TextEncoder","encode_text","encode","bind","text_decoder","TextDecoder","decode_text","decode","WispBuffer","constructor","data","Uint8Array","from_array","trace","size","view","DataView","buffer","concat","new_buffer","set","bytes_slice","get_string","WispPacket","static","type","stream_id","payload","payload_bytes","getUint8","getUint32","parse_all","min_size","TypeError","packet","payload_class","packet_classes","serialize","setUint8","setUint32","ConnectPayload","stream_type","port","hostname","getUint16","setUint16","DataPayload","ContinuePayload","buffer_remaining","ClosePayload","reason","InfoPayload","major_ver","minor_ver","extensions","packet_types","CONNECT","DATA","CONTINUE","CLOSE","stream_types","TCP","UDP","close_reasons","Unknown","Voluntary","NetworkError","IncompatibleExtensions","InvalidInfo","UnreachableHost","NoResponse","ConnRefused","TransferTimeout","HostBlocked","ConnThrottled","ClientError","AuthBadPassword","AuthBadSignature","AuthMissingCredentials","options","hostname_blacklist","hostname_whitelist","port_blacklist","port_whitelist","allow_direct_ip","allow_private_ips","allow_loopback_ips","client_ip_blacklist","client_ip_whitelist","stream_limit_per_host","stream_limit_total","allow_udp_streams","allow_tcp_streams","dns_ttl","dns_method","dns_servers","dns_result_order","parse_real_ip","parse_real_ip_from","wisp_version","wisp_motd","global_this","globalThis","window","WebSocket","crypto","net","http","AsyncWebSocket","send_buffer_size","ws","connected","data_queue","AsyncQueue","connect","Promise","resolve","reject","onopen","onmessage","event","put","onclose","close","readyState","OPEN","recv","send","bufferedAmount","setTimeout","code","buffered_amount","max_size","queue","put_callbacks","get_callbacks","put_now","get_now","callback","is_node","dns_cache","Map","resolver","assert_on_node","resolve4","resolve6","async","resolve_with_fallback","resolve_first","resolve_after","lookup_ip","ip_level","isIP","now","entry_hostname","cache_entry","delete","lookup","order","Resolver","setServers","perform_lookup","NodeTCPSocket","recv_buffer_size","socket","paused","ip","Socket","setNoDelay","on","destroy","host","write","end","pause","resume","NodeUDPSocket","createSocket","AccessDeniedError","check_port_range","entry","check_whitelist","entries","filter","matched","check_blacklist","check_ip_range","includes","is_stream_allowed","connection","ip_str","is_ip_blocked","keys","streams","streams_per_host","stream","EmptyPayload","BaseExtension","server_config","client_config","id","name","Server","Client","ext_class","role","extension","payload_buffer","setInt8","UDPExtension","PasswordAuthExtension","required","username","password","username_len","password_len","password_index","username_buffer","password_buffer","MOTDExtension","message","parse_extensions","valid_extensions","parsed_extensions","ext_id","ext_len","ext_payload","ext_parsed","serialize_extensions","ext_buffer","extensions_map","HandshakeError","ServerStream","conn","send_buffer","buffer_size","packets_sent","setup","tcp_to_ws","catch","conn_id","ws_to_tcp","close_stream","put_data","ServerConnection","path","TCPSocket","UDPSocket","ping_interval","wisp_extensions","ping_task","randomUUID","server_exts","client_exts","add_extensions","setup_wisp_v2","continue_packet","ping","setInterval","info_packet","cleanup","client_extensions","client_ext","server_ext","create_stream","close_reason","quiet","route_packet","type_info","trim","run","clearInterval","WSProxyConnection","pop","ws_server","headers","client_ip","routeRequest","request","head","conn_options","IncomingMessage","handleUpgrade","create_connection","url","binaryType","wisp_conn","wsproxy","stack","noServer"],"sourceRoot":""}